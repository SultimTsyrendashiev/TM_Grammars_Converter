; ѕроверка числа на простоту

; ¬ход: положительное число в виде количества знаков "I".  аретка указывает на самый левый символ "I"
; ¬ыход: изначальное число (в том же виде) и после этого числа и одного бланка: либо I, если число простое, либо бланк, если число не простое.  аретка указывает на место результата

; ѕример входа:  "_IIIII_"
; ѕример выхода: "_IIIII_I_"

; ѕример входа:  "_IIII_"
; ѕример выхода: "_IIII___"

; «амечание: знак бланка - это "_"
; «амечание: пусть 1 - не простое число



; обозначим за a - входное число

; состо€ни€ 0 - проверка, что a == 1
; состо€ние "0" - это начальное состо€ние
0 I I r 0_1
0_1 I I l 1_0
0_1 _ _ r not_prime


; состо€ни€ 1 - копирование (a-1) справа от a
; обозначим за b = a-1
1_0 I # r 1_1
1_1 I I r 1_1
1_1 _ _ r 1_2
1_2 # # r 1_2
1_2 _ # l 1_3
1_3 # # l 1_3
1_3 _ _ l 1_4
1_4 I I l 1_5
1_5 I I l 1_5
1_5 # # r 1_0
1_4 # # r 1_6
1_6 _ _ r 1_7
1_7 # # r 1_7
1_7 _ _ l 1_8
1_8 # _ l 1_9
1_9 # # l 1_9
1_9 _ _ r 2_0


; состо€ни€ 2 - цикл while (b != 1)
2_0 # # r 2_1
2_1 # # l 2_2
2_2 # # l 4_0

; если b==1
2_1 _ _ l halt_prime


; состо€ни€ 4 - копирование a дл€ вычислени€ (a mod b)
4_0 _ _ l 4_1
4_1 # # l 4_1
4_1 _ _ r 4_2

4_2 # o r 4_3
4_3 # # r 4_3
4_3 _ _ r 4_4
4_4 # # r 4_4
4_4 _ _ r 4_5
4_5 # # r 4_5
4_5 _ # l 4_6
4_6 # # l 4_6
4_6 _ _ l 4_7
4_7 # # l 4_7
4_7 _ _ l 4_8
4_8 # # l 4_9
4_9 # # l 4_9
4_9 o o r 4_2

4_8 o # l 4_10
4_10 o # l 4_10
4_10 _ _ r 4_11
4_11 # # r 4_11
4_11 _ _ r 5_0


; состо€ни€ 5 - (a mod b): пробуем вычитать, если получаетс€, продолжаем, иначе - нашли (a mod b)
; состо€ни€ 6 - пробуем вычитать
; состо€ни€ 7 - если не можем больше вычитать

5_0 # o r 5_1

5_1 # # r 5_1
5_1 _ _ r 5_2
5_2 # # r 5_2
5_2 _ _ l 5_3
5_2 o o l 5_3 

5_3 # o l 6_0
5_3 _ _ l 7_0

6_0 # # l 6_0
6_0 _ _ l 6_1
6_1 # # l 6_1
6_1 o o r 6_2

; продолжаем копировать "o" в результат mod
6_2 # o r 5_1

; если закончили копировать, удал€ем "o" в рузультате mod, также замен€ем "o" на "#" в b
6_2 _ _ l 6_3
6_3 o # l 6_3
6_3 _ _ r 6_4
6_4 # # r 6_4

; "A" - специальный символ дл€ опредени€ границы
6_4 _ A r 6_5
6_5 # # r 6_5
6_5 o _ r 6_5
6_5 _ _ l 6_6
6_6 _ _ l 6_6
6_6 # # l 6_6
6_6 A _ l 6_7
6_7 # # l 6_7


; вычли, теперь возвращемс€, чтобы попробовать ещЄ раз вычесть
6_7 _ _ r 5_0


7_0 o # l 7_0
7_0 # # l 7_0
7_0 _ _ r 7_1
7_1 # # r 7_1
7_1 _ _ r 7_2
7_2 o # r 7_2
7_2 _ _ l 7_3
7_3 # # l 7_3
7_3 _ _ r 7_4
7_4 # _ r 9_0

; если (a mod b) == 0
7_4 _ _ l not_prime



; состо€ни€ 9 - b = b-1, идем в while
9_0 # _ r 9_0
9_0 _ _ l 9_1
9_1 _ _ l 9_1
9_1 # _ l 9_2
9_2 # # l 9_2
9_2 _ _ r 2_0