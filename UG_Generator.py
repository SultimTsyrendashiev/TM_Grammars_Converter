import sys
import random

def main(argv):
    
    if len(argv) < 2:
        print('Expected input: <input_unrestricted_grammar_file>')
        return

    # how many words to create
    wordsAmount = 7
    
    # how many space there needed after a word;
    # f.e.: if word is 'II' but 
    # number of blanks that uses TM is five times larger,
    # then multiplier must be 5
    lineMultiplier = 5
   
    with open(argv[1]) as f:
        lines = f.readlines()

    lines = [x.strip() for x in lines]

    productions = []
    heads = []

    for line in lines:
        splitted = line.split('->')

        head = ' ' + splitted[0] if len(splitted) == 2 else ' ' + splitted[0] + ' '
        tail = splitted[1] + ' ' if len(splitted) == 2 else '' # check epsilon

        heads.append(head)

        productions.append((head, tail))

    # generate words from steps 1-5, which contain non-determinism.
    # in this program non-determinism is not used,
    # instead of it, we create special initial words 
    # that can be generated by non-determinism
    initialWords = []
    ndProductions = productions[0:5] # copy first 5 productions

    # adding blank symbol to the left of word 
    # as grammar that simulates TM works only on a half of the line
    initialNt = ' (,_) A1 '

    for i in range(1, wordsAmount + 1):
        word = initialNt
        # check each production
        for head, tail in ndProductions:
            limit = i
            
            # how many blanks must be after a word
            if 'A3' in head and 'A3' in tail:
                limit = i * lineMultiplier

            word = simulateProductionLimited(word, head, tail, limit)

        initialWords.append(word)

    # actual simulation of the grammar
    for i in range(0, wordsAmount):
        current = initialWords[i]
        
        finished = True

        # while there are non terminals
        while containsNonTerminal(current, heads):

            # save previous
            prev = str(current)

            # check each production
            for head, tail in productions:
                current = simulateProduction(current, head, tail)

            # if word doesn't change, but word contain non terminals
            # then error
            if prev == current:
                finished = False
                break

        # print only finished generated words
        if (finished):
            printTMWord(current)

def simulateProduction(current, head, tail):
    # while head is contained by current
    while head in current:
        current = current.replace(head, tail, 1)
        #print(current)
        #printTM(current)

    return current

def simulateProductionLimited(current, head, tail, limit):
    '''Same as simulateProduction, but number of replacements of current production is limited'''
    iteration = 0
    while head in current and iteration < limit:
        current = current.replace(head, tail, 1)
        iteration += 1
        #print(current)
        #printTM(current)

    return current

def containsNonTerminal(str, productionHeads):
    nonTerminals = set()
    for head in productionHeads:
        ws = set(head.split(' '));
        nonTerminals = nonTerminals.union(ws)

    # ignore epsilon
    if '' in nonTerminals:
        nonTerminals.remove('')

    # ignore first non terminal, as it's '(,_)'
    str = str.replace('(,_)', '', 1)

    return any(nonTerm in str for nonTerm in nonTerminals)

def printTM(str):
    '''Print turing machine's line'''
    out = ''
    splitted = str.split(' ')
    for s in splitted:
        if '(' in s:
            s = s.replace(')', '')
            tuple = s.split(',')
            out += tuple[1]
    print(out)

def printTMWord(str):
    '''Print turing machine's initial word. Ignores spaces and first '(,_)' in the beginning'''
    out = ''
    splitted = str.split(' ')

    if '(,_)' in splitted:
        splitted.remove('(,_)')

    for s in splitted:
        out += s

    print(out)


# call main method
main(sys.argv)